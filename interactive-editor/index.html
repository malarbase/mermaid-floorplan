<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Floorplan Editor</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        overflow: hidden;
        background: #1a1a1a;
      }
      
      .container {
        display: flex;
        width: 100vw;
        height: 100vh;
      }
      
      /* Left panel: Code editor */
      .editor-panel {
        width: 40%;
        min-width: 300px;
        max-width: 600px;
        height: 100%;
        display: flex;
        flex-direction: column;
        border-right: 1px solid #333;
        background: #1e1e1e;
      }
      
      .editor-header {
        padding: 12px 16px;
        background: #252526;
        border-bottom: 1px solid #333;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .editor-header h2 {
        font-size: 14px;
        font-weight: 500;
        color: #ccc;
      }
      
      .editor-status {
        font-size: 12px;
        color: #888;
      }
      
      .editor-status.error {
        color: #f44;
      }
      
      .editor-status.success {
        color: #4a4;
      }
      
      #editor-container {
        flex: 1;
        overflow: hidden;
      }
      
      /* Right panel: 3D viewer */
      .viewer-panel {
        flex: 1;
        position: relative;
        background: #1a1a1a;
      }
      
      #app {
        width: 100%;
        height: 100%;
      }
      
      /* Info panel overlay */
      .info-panel {
        position: absolute;
        top: 16px;
        right: 16px;
        background: rgba(0, 0, 0, 0.85);
        color: white;
        padding: 16px;
        border-radius: 8px;
        font-size: 13px;
        max-width: 280px;
        z-index: 100;
        border: 1px solid #333;
      }
      
      .info-panel h3 {
        margin-bottom: 8px;
        font-size: 12px;
        color: #888;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      
      .info-panel p {
        margin-bottom: 4px;
        color: #ccc;
        font-size: 12px;
      }
      
      .key {
        display: inline-block;
        background: #333;
        padding: 1px 5px;
        border-radius: 3px;
        font-family: monospace;
        font-size: 11px;
        margin: 0 2px;
        border: 1px solid #555;
      }
      
      .mode-toggle {
        margin-top: 10px;
        padding-top: 10px;
        border-top: 1px solid #444;
      }
      
      .mode-toggle label {
        display: flex;
        align-items: center;
        gap: 6px;
        cursor: pointer;
        color: #ccc;
        font-size: 12px;
      }
      
      .mode-toggle input[type="checkbox"] {
        width: 14px;
        height: 14px;
        cursor: pointer;
      }
      
      .mode-indicator {
        margin-top: 6px;
        padding: 4px 8px;
        background: #2a2a2a;
        border-radius: 4px;
        font-size: 11px;
        color: #4a9eff;
      }
      
      /* Selection info panel */
      .selection-info {
        position: absolute;
        bottom: 16px;
        right: 16px;
        background: rgba(0, 0, 0, 0.85);
        color: white;
        padding: 12px 16px;
        border-radius: 8px;
        font-size: 14px;
        z-index: 100;
        border: 1px solid #333;
        min-width: 180px;
      }
      
      .selection-info.has-selection {
        border-color: #00ff00;
        background: rgba(0, 40, 0, 0.85);
      }
      
      .selection-info .count {
        font-size: 20px;
        font-weight: bold;
        color: #00ff00;
        margin-bottom: 2px;
      }
      
      .selection-info .details {
        color: #aaa;
        font-size: 11px;
      }
      
      /* Resizer */
      .resizer {
        width: 4px;
        background: #333;
        cursor: col-resize;
        transition: background 0.2s;
      }
      
      .resizer:hover {
        background: #4a9eff;
      }
      
      /* Error banner */
      .error-banner {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        padding: 8px 16px;
        background: rgba(244, 67, 54, 0.9);
        color: white;
        font-size: 13px;
        z-index: 200;
        display: none;
      }
      
      .error-banner.visible {
        display: block;
      }
      
      /* Wall selection hint decoration */
      .wall-selection-hint {
        color: #4a9eff;
        font-style: italic;
        margin-left: 8px;
        opacity: 0.9;
      }
      
      /* Multi-selection highlighting in editor (for 3D multi-select → editor sync) */
      .selected-entity-decoration {
        background-color: rgba(0, 255, 0, 0.15);
        border-radius: 2px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Editor Panel -->
      <div class="editor-panel">
        <div class="editor-header">
          <h2>Floorplan DSL</h2>
          <span id="editor-status" class="editor-status">Ready</span>
        </div>
        <div id="editor-container"></div>
      </div>
      
      <!-- Resizer -->
      <div class="resizer" id="resizer"></div>
      
      <!-- 3D Viewer Panel -->
      <div class="viewer-panel">
        <div class="error-banner" id="error-banner"></div>
        <div id="app"></div>
        
        <div class="info-panel">
          <h3>Selection</h3>
          <p><span class="key">Click</span> Select</p>
          <p><span class="key">Shift+Click</span> Add to selection</p>
          <p><span class="key">Drag</span> Marquee select</p>
          <p><span class="key">Ctrl/⌘+A</span> Select all</p>
          <p><span class="key">Esc</span> Deselect</p>
          
          <h3>Camera</h3>
          <p><span class="key">Alt+Drag</span> Orbit</p>
          <p><span class="key">Right-drag</span> Pan</p>
          <p><span class="key">Scroll</span> Zoom</p>
          
          <div class="mode-toggle">
            <label>
              <input type="checkbox" id="containment-mode">
              Containment mode
            </label>
            <div class="mode-indicator" id="mode-indicator">
              Intersection
            </div>
          </div>
        </div>
        
        <div id="selection-info" class="selection-info">
          <div class="details">No selection</div>
        </div>
      </div>
    </div>
    
    <script type="module">
      import { InteractiveEditor } from './src/interactive-editor.ts';
      import { createDslEditor } from './src/dsl-editor.ts';
      import { EditorViewerSync } from './src/editor-viewer-sync.ts';
      import { EmptyFileSystem } from 'langium';
      import { createFloorplansServices, convertFloorplanToJson } from 'floorplans-language';
      
      // Sample DSL content
      const sampleDsl = `floorplan
  config {
    default_height: 2.8,
    wall_thickness: 0.15,
    floor_thickness: 0.1
  }
  
  floor GroundFloor {
    room LivingRoom at (0, 0) size (8 x 6) walls [top: solid, right: solid, bottom: solid, left: solid]
    room Kitchen at (8.5, 0) size (5 x 6) walls [top: solid, right: solid, bottom: solid, left: open]
    room DiningRoom at (14, 0) size (5 x 6) walls [top: solid, right: solid, bottom: solid, left: solid]
    room Bedroom at (0, 7) size (6 x 5) walls [top: solid, right: solid, bottom: solid, left: solid]
    room Bathroom at (6.5, 7) size (4 x 5) walls [top: solid, right: solid, bottom: solid, left: solid]
    room Office at (11, 7) size (5 x 5) walls [top: solid, right: solid, bottom: solid, left: solid]
  }
  
  connect LivingRoom.right to Kitchen.left door at 50%
  connect Kitchen.right to DiningRoom.left door at 50%
`;
      
      // Initialize Langium services
      const services = createFloorplansServices(EmptyFileSystem);
      const parser = services.Floorplans.parser.LangiumParser;
      
      // State
      let currentJsonData = null;
      let editorSync = null;
      let parseDebounceTimeout = null;
      
      // Create DSL editor
      const dslEditor = createDslEditor({
        containerId: 'editor-container',
        initialContent: sampleDsl,
        theme: 'vs-dark',
        fontSize: 13,
        onChange: (content) => {
          // Debounce parsing
          if (parseDebounceTimeout) {
            clearTimeout(parseDebounceTimeout);
          }
          parseDebounceTimeout = setTimeout(() => {
            parseAndUpdate(content);
          }, 300);
        },
      });
      
      // Create 3D editor (initially with sample data)
      const editor3d = new InteractiveEditor({
        containerId: 'app',
        enableSelection: true,
      });
      
      // UI elements
      const editorStatus = document.getElementById('editor-status');
      const errorBanner = document.getElementById('error-banner');
      const selectionInfo = document.getElementById('selection-info');
      const containmentCheckbox = document.getElementById('containment-mode');
      const modeIndicator = document.getElementById('mode-indicator');
      
      /**
       * Parse DSL and update 3D view
       */
      async function parseAndUpdate(content) {
        try {
          // Parse the DSL
          const parseResult = parser.parse(content);
          
          if (parseResult.lexerErrors.length > 0 || parseResult.parserErrors.length > 0) {
            const errors = [
              ...parseResult.lexerErrors.map(e => ({
                line: e.line ?? 1,
                column: e.column ?? 1,
                message: e.message,
              })),
              ...parseResult.parserErrors.map(e => ({
                line: e.token?.startLine ?? 1,
                column: e.token?.startColumn ?? 1,
                message: e.message,
              })),
            ];
            
            showError(errors[0].message);
            dslEditor.setErrorMarkers(errors);
            editorStatus.textContent = `${errors.length} error(s)`;
            editorStatus.className = 'editor-status error';
            // Set error state (3D view keeps last valid geometry)
            editor3d.setErrorState(true);
            return;
          }
          
          // Convert to JSON
          const conversionResult = convertFloorplanToJson(parseResult.value);
          
          if (conversionResult.errors.length > 0) {
            showError(conversionResult.errors[0].message);
            editorStatus.textContent = 'Conversion error';
            editorStatus.className = 'editor-status error';
            // Set error state (3D view keeps last valid geometry)
            editor3d.setErrorState(true);
            return;
          }
          
          // Success - update 3D view
          currentJsonData = conversionResult.data;
          editor3d.loadFloorplan(currentJsonData);
          
          // Update entity locations for sync
          if (editorSync) {
            const entityLocations = extractEntityLocations(currentJsonData);
            editorSync.updateEntityLocations(entityLocations);
          }
          
          // Clear errors (loadFloorplan already clears error state)
          hideError();
          dslEditor.clearErrorMarkers();
          editorStatus.textContent = 'Ready';
          editorStatus.className = 'editor-status success';
          
        } catch (err) {
          showError(err.message);
          editorStatus.textContent = 'Parse error';
          editorStatus.className = 'editor-status error';
          // Set error state (3D view keeps last valid geometry)
          editor3d.setErrorState(true);
        }
      }
      
      /**
       * Extract entity locations from JSON for editor sync
       */
      function extractEntityLocations(jsonData) {
        const locations = [];
        
        for (const floor of jsonData.floors) {
          for (const room of floor.rooms) {
            if (room._sourceRange) {
              locations.push({
                entityType: 'room',
                entityId: room.name,
                floorId: floor.id,
                sourceRange: room._sourceRange,
              });
            }
            
            // Extract wall locations for wall direction → 3D highlight sync
            for (const wall of room.walls || []) {
              if (wall._sourceRange) {
                locations.push({
                  entityType: 'wall',
                  entityId: `${room.name}_${wall.direction}`,
                  floorId: floor.id,
                  sourceRange: wall._sourceRange,
                });
              }
            }
          }
        }
        
        for (const conn of jsonData.connections) {
          if (conn._sourceRange) {
            locations.push({
              entityType: 'connection',
              entityId: `${conn.fromRoom}-${conn.toRoom}`,
              floorId: jsonData.floors[0]?.id ?? 'default',
              sourceRange: conn._sourceRange,
            });
          }
        }
        
        return locations;
      }
      
      /**
       * Show error in banner
       */
      function showError(message) {
        errorBanner.textContent = message;
        errorBanner.classList.add('visible');
      }
      
      /**
       * Hide error banner
       */
      function hideError() {
        errorBanner.classList.remove('visible');
      }
      
      /**
       * Update selection info display
       */
      function updateSelectionInfo(selection) {
        const count = selection.size;
        
        if (count === 0) {
          selectionInfo.innerHTML = '<div class="details">No selection</div>';
          selectionInfo.classList.remove('has-selection');
        } else {
          const types = new Map();
          for (const obj of selection) {
            types.set(obj.entityType, (types.get(obj.entityType) || 0) + 1);
          }
          
          const summary = Array.from(types.entries())
            .map(([type, cnt]) => `${cnt} ${type}${cnt > 1 ? 's' : ''}`)
            .join(', ');
          
          let names = '';
          if (count <= 3) {
            names = Array.from(selection).map(s => s.entityId).join(', ');
          }
          
          selectionInfo.innerHTML = `
            <div class="count">${count}</div>
            <div class="details">${summary}</div>
            ${names ? `<div class="details" style="margin-top: 4px; color: #00ff00;">${names}</div>` : ''}
          `;
          selectionInfo.classList.add('has-selection');
        }
      }
      
      // Setup selection manager listeners
      if (editor3d.selectionManager) {
        editor3d.selectionManager.onSelectionChange((event) => {
          updateSelectionInfo(event.selection);
        });
        
        // Setup bidirectional sync
        editorSync = new EditorViewerSync(
          dslEditor.editor,
          editor3d.selectionManager,
          { debug: false }
        );
        
        // Handle editor cursor → 3D selection (supports multi-cursor)
        editorSync.onEditorSelect((entityKey, isAdditive) => {
          // Parse the key: floorId:entityType:entityId
          const parts = entityKey.split(':');
          if (parts.length !== 3) return;
          
          const [floorId, entityType, entityId] = parts;
          
          // Find the entity in the registry and select it
          const registry = editor3d.meshRegistry;
          const entities = registry.getAllEntities();
          
          for (const entity of entities) {
            if (entity.floorId === floorId && 
                entity.entityType === entityType && 
                entity.entityId === entityId) {
              // Use isAdditive for multi-cursor support
              editor3d.selectionManager.select(entity, isAdditive);
              break;
            }
          }
        });
        
        // Handle editor text highlight → 3D preview highlight
        editorSync.onEditorHighlight((entityKeys) => {
          // Clear existing highlights first
          editor3d.selectionManager.clearHighlight();
          
          const registry = editor3d.meshRegistry;
          const entities = registry.getAllEntities();
          
          for (const entityKey of entityKeys) {
            const parts = entityKey.split(':');
            if (parts.length !== 3) continue;
            
            const [floorId, entityType, entityId] = parts;
            
            for (const entity of entities) {
              if (entity.floorId === floorId && 
                  entity.entityType === entityType && 
                  entity.entityId === entityId) {
                // Highlight (preview) without selecting
                editor3d.selectionManager.highlight(entity);
                break;
              }
            }
          }
        });
        
        // Handle clear highlight when text selection is cleared
        editorSync.onEditorHighlightClear(() => {
          editor3d.selectionManager.clearHighlight();
        });
      }
      
      // Mode toggle
      containmentCheckbox.addEventListener('change', (e) => {
        const mode = e.target.checked ? 'containment' : 'intersection';
        editor3d.setMarqueeMode(mode);
        modeIndicator.textContent = mode === 'containment' ? 'Containment' : 'Intersection';
        modeIndicator.style.color = mode === 'containment' ? '#ff9500' : '#4a9eff';
      });
      
      // Initialize mode from saved preference
      try {
        const savedMode = localStorage.getItem('floorplan-marquee-mode');
        if (savedMode === 'containment') {
          containmentCheckbox.checked = true;
          editor3d.setMarqueeMode('containment');
          modeIndicator.textContent = 'Containment';
          modeIndicator.style.color = '#ff9500';
        }
      } catch (e) {}
      
      // Resizer functionality
      const resizer = document.getElementById('resizer');
      const editorPanel = document.querySelector('.editor-panel');
      let isResizing = false;
      
      resizer.addEventListener('mousedown', (e) => {
        isResizing = true;
        document.body.style.cursor = 'col-resize';
        e.preventDefault();
      });
      
      document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;
        const newWidth = e.clientX;
        if (newWidth >= 200 && newWidth <= 800) {
          editorPanel.style.width = `${newWidth}px`;
        }
      });
      
      document.addEventListener('mouseup', () => {
        isResizing = false;
        document.body.style.cursor = '';
      });
      
      // Initial parse
      parseAndUpdate(sampleDsl);
      
      // Expose for debugging
      window.editor3d = editor3d;
      window.dslEditor = dslEditor;
      window.editorSync = editorSync;
      console.log('Interactive Editor with DSL sync initialized');
      console.log('Access: window.editor3d, window.dslEditor, window.editorSync');
    </script>
  </body>
</html>
