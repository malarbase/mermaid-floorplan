<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Floorplan Editor</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        overflow: hidden;
        background: #1a1a1a;
      }
      
      .container {
        display: flex;
        width: 100vw;
        height: 100vh;
      }
      
      /* Left panel: Code editor */
      .editor-panel {
        width: 40%;
        min-width: 300px;
        max-width: 600px;
        height: 100%;
        display: flex;
        flex-direction: column;
        border-right: 1px solid #333;
        background: #1e1e1e;
      }
      
      .editor-header {
        padding: 12px 16px;
        background: #252526;
        border-bottom: 1px solid #333;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
      }
      
      .editor-header h2 {
        font-size: 14px;
        font-weight: 500;
        color: #ccc;
      }
      
      .editor-header-right {
        display: flex;
        align-items: center;
        gap: 12px;
      }
      
      .editor-status {
        font-size: 12px;
        color: #888;
      }
      
      /* Export dropdown */
      .export-dropdown {
        position: relative;
      }
      
      .export-btn {
        background: #3c3c3c;
        border: 1px solid #555;
        color: #ccc;
        padding: 4px 12px;
        border-radius: 4px;
        font-size: 12px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 4px;
      }
      
      .export-btn:hover {
        background: #4a4a4a;
        border-color: #666;
      }
      
      .export-btn::after {
        content: '▾';
        font-size: 10px;
        margin-left: 2px;
      }
      
      .export-menu {
        position: absolute;
        top: 100%;
        right: 0;
        margin-top: 4px;
        background: #2d2d2d;
        border: 1px solid #555;
        border-radius: 4px;
        min-width: 160px;
        z-index: 300;
        display: none;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      }
      
      .export-menu.visible {
        display: block;
      }
      
      .export-menu-item {
        padding: 8px 12px;
        font-size: 12px;
        color: #ccc;
        cursor: pointer;
        border: none;
        background: none;
        width: 100%;
        text-align: left;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .export-menu-item:hover {
        background: #3c3c3c;
      }
      
      .export-menu-item:first-child {
        border-radius: 3px 3px 0 0;
      }
      
      .export-menu-item:last-child {
        border-radius: 0 0 3px 3px;
      }
      
      .export-menu-item .ext {
        color: #888;
        font-size: 11px;
      }
      
      .export-menu-divider {
        height: 1px;
        background: #444;
        margin: 4px 0;
      }
      
      /* Add Room button */
      .add-room-btn {
        background: #2d5a2d;
        border: 1px solid #4a8a4a;
        color: #8f8;
        padding: 4px 12px;
        border-radius: 4px;
        font-size: 12px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 4px;
      }
      
      .add-room-btn:hover {
        background: #3a6a3a;
        border-color: #5a9a5a;
      }
      
      .add-room-btn::before {
        content: '+';
        font-weight: bold;
        font-size: 14px;
      }
      
      /* Add room dialog */
      .dialog-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.6);
        z-index: 400;
        display: none;
        align-items: center;
        justify-content: center;
      }
      
      .dialog-overlay.visible {
        display: flex;
      }
      
      .dialog {
        background: #2d2d2d;
        border: 1px solid #555;
        border-radius: 8px;
        padding: 20px;
        min-width: 320px;
        box-shadow: 0 8px 32px rgba(0,0,0,0.4);
      }
      
      .dialog-title {
        font-size: 16px;
        font-weight: 600;
        color: #fff;
        margin-bottom: 16px;
      }
      
      .dialog-field {
        margin-bottom: 12px;
      }
      
      .dialog-field label {
        display: block;
        font-size: 12px;
        color: #999;
        margin-bottom: 4px;
      }
      
      .dialog-field input {
        width: 100%;
        background: #1e1e1e;
        border: 1px solid #555;
        border-radius: 4px;
        padding: 8px 10px;
        color: #fff;
        font-size: 13px;
      }
      
      .dialog-field input:focus {
        outline: none;
        border-color: #4a9eff;
      }
      
      .dialog-row {
        display: flex;
        gap: 12px;
      }
      
      .dialog-row .dialog-field {
        flex: 1;
      }
      
      .dialog-buttons {
        display: flex;
        justify-content: flex-end;
        gap: 8px;
        margin-top: 20px;
      }
      
      .dialog-btn {
        padding: 8px 16px;
        border-radius: 4px;
        font-size: 13px;
        cursor: pointer;
        border: 1px solid transparent;
      }
      
      .dialog-btn.cancel {
        background: #3c3c3c;
        border-color: #555;
        color: #ccc;
      }
      
      .dialog-btn.cancel:hover {
        background: #4a4a4a;
      }
      
      .dialog-btn.primary {
        background: #2d5a2d;
        border-color: #4a8a4a;
        color: #8f8;
      }
      
      .dialog-btn.primary:hover {
        background: #3a6a3a;
      }
      
      .dialog-error {
        color: #f44;
        font-size: 12px;
        margin-top: 8px;
        display: none;
      }
      
      .dialog-error.visible {
        display: block;
      }
      
      .editor-status.error {
        color: #f44;
      }
      
      .editor-status.success {
        color: #4a4;
      }
      
      #editor-container {
        flex: 1;
        overflow: hidden;
      }
      
      /* Right panel: 3D viewer */
      .viewer-panel {
        flex: 1;
        position: relative;
        background: #1a1a1a;
      }
      
      #app {
        width: 100%;
        height: 100%;
      }
      
      /* Info panel overlay */
      .info-panel {
        position: absolute;
        top: 16px;
        right: 16px;
        background: rgba(0, 0, 0, 0.85);
        color: white;
        padding: 16px;
        border-radius: 8px;
        font-size: 13px;
        max-width: 280px;
        z-index: 100;
        border: 1px solid #333;
      }
      
      .info-panel h3 {
        margin-bottom: 8px;
        font-size: 12px;
        color: #888;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      
      .info-panel p {
        margin-bottom: 4px;
        color: #ccc;
        font-size: 12px;
      }
      
      .key {
        display: inline-block;
        background: #333;
        padding: 1px 5px;
        border-radius: 3px;
        font-family: monospace;
        font-size: 11px;
        margin: 0 2px;
        border: 1px solid #555;
      }
      
      .mode-toggle {
        margin-top: 10px;
        padding-top: 10px;
        border-top: 1px solid #444;
      }
      
      .mode-toggle label {
        display: flex;
        align-items: center;
        gap: 6px;
        cursor: pointer;
        color: #ccc;
        font-size: 12px;
      }
      
      .mode-toggle input[type="checkbox"] {
        width: 14px;
        height: 14px;
        cursor: pointer;
      }
      
      .mode-indicator {
        margin-top: 6px;
        padding: 4px 8px;
        background: #2a2a2a;
        border-radius: 4px;
        font-size: 11px;
        color: #4a9eff;
      }
      
      /* Selection info panel */
      .selection-info {
        position: absolute;
        bottom: 16px;
        right: 16px;
        background: rgba(0, 0, 0, 0.85);
        color: white;
        padding: 12px 16px;
        border-radius: 8px;
        font-size: 14px;
        z-index: 100;
        border: 1px solid #333;
        min-width: 180px;
      }
      
      .selection-info.has-selection {
        border-color: #00ff00;
        background: rgba(0, 40, 0, 0.85);
      }
      
      .selection-info .count {
        font-size: 20px;
        font-weight: bold;
        color: #00ff00;
        margin-bottom: 2px;
      }
      
      .selection-info .details {
        color: #aaa;
        font-size: 11px;
      }
      
      /* Resizer */
      .resizer {
        width: 4px;
        background: #333;
        cursor: col-resize;
        transition: background 0.2s;
      }
      
      .resizer:hover {
        background: #4a9eff;
      }
      
      /* Error banner */
      .error-banner {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        padding: 8px 16px;
        background: rgba(244, 67, 54, 0.9);
        color: white;
        font-size: 13px;
        z-index: 200;
        display: none;
      }
      
      .error-banner.visible {
        display: block;
      }
      
      /* Error state dimming overlay for 3D scene */
      .error-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.3);
        pointer-events: none; /* Allow clicks to pass through to 3D scene */
        z-index: 50;
        display: none;
        border: 3px solid rgba(244, 67, 54, 0.6);
        box-sizing: border-box;
      }
      
      .error-overlay.visible {
        display: block;
      }
      
      .error-overlay::after {
        content: 'Viewing stale geometry';
        position: absolute;
        bottom: 60px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(244, 67, 54, 0.85);
        color: white;
        padding: 6px 12px;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap;
      }
      
      /* Wall selection hint decoration */
      .wall-selection-hint {
        color: #4a9eff;
        font-style: italic;
        margin-left: 8px;
        opacity: 0.9;
      }
      
      /* Multi-selection highlighting in editor (for 3D multi-select → editor sync) */
      .selected-entity-decoration {
        background-color: rgba(0, 255, 0, 0.15);
        border-radius: 2px;
      }
      
      /* Properties Panel */
      .properties-panel {
        position: absolute;
        top: 16px;
        left: 16px;
        background: rgba(0, 0, 0, 0.9);
        color: white;
        border-radius: 8px;
        min-width: 220px;
        max-width: 280px;
        z-index: 100;
        border: 1px solid #333;
        display: none;
      }
      
      .properties-panel-content {
        padding: 12px;
      }
      
      .properties-panel-title {
        font-size: 14px;
        font-weight: 600;
        color: #fff;
        margin-bottom: 12px;
        padding-bottom: 8px;
        border-bottom: 1px solid #444;
      }
      
      .properties-panel-form {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      
      .property-row {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      
      .property-label {
        flex: 0 0 80px;
        font-size: 12px;
        color: #999;
      }
      
      .property-input {
        flex: 1;
        background: #333;
        border: 1px solid #555;
        border-radius: 4px;
        padding: 4px 8px;
        color: #fff;
        font-size: 12px;
        min-width: 0;
      }
      
      .property-input:focus {
        outline: none;
        border-color: #4a9eff;
      }
      
      .property-value.readonly {
        flex: 1;
        color: #888;
        font-size: 12px;
      }
      
      .properties-panel-note {
        margin-top: 12px;
        padding-top: 8px;
        border-top: 1px solid #444;
        font-size: 11px;
        color: #666;
        font-style: italic;
      }
      
      .properties-panel-actions {
        margin-top: 12px;
        padding-top: 12px;
        border-top: 1px solid #444;
        display: flex;
        justify-content: flex-end;
      }
      
      .delete-btn {
        background: #5a2d2d;
        border: 1px solid #8a4a4a;
        color: #f88;
        padding: 6px 12px;
        border-radius: 4px;
        font-size: 12px;
        cursor: pointer;
      }
      
      .delete-btn:hover {
        background: #6a3a3a;
        border-color: #9a5a5a;
      }
      
      /* Confirm delete dialog */
      .confirm-dialog {
        background: #2d2d2d;
        border: 1px solid #555;
        border-radius: 8px;
        padding: 20px;
        min-width: 320px;
        max-width: 420px;
        box-shadow: 0 8px 32px rgba(0,0,0,0.4);
      }
      
      .confirm-dialog-title {
        font-size: 16px;
        font-weight: 600;
        color: #f88;
        margin-bottom: 12px;
      }
      
      .confirm-dialog-message {
        font-size: 13px;
        color: #ccc;
        margin-bottom: 12px;
        line-height: 1.5;
      }
      
      .confirm-dialog-warning {
        background: rgba(244, 136, 136, 0.15);
        border: 1px solid rgba(244, 136, 136, 0.3);
        border-radius: 4px;
        padding: 10px;
        margin-bottom: 16px;
      }
      
      .confirm-dialog-warning-title {
        font-size: 12px;
        font-weight: 600;
        color: #f88;
        margin-bottom: 6px;
      }
      
      .confirm-dialog-warning-list {
        font-size: 11px;
        color: #ccc;
        margin: 0;
        padding-left: 16px;
      }
      
      .confirm-dialog-warning-list li {
        margin-bottom: 2px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Editor Panel -->
      <div class="editor-panel">
        <div class="editor-header">
          <h2>Floorplan DSL</h2>
          <div class="editor-header-right">
            <button class="add-room-btn" id="add-room-btn">Room</button>
            <div class="export-dropdown">
              <button class="export-btn" id="export-btn">Export</button>
              <div class="export-menu" id="export-menu">
                <button class="export-menu-item" data-format="dsl">
                  Floorplan DSL <span class="ext">.floorplan</span>
                </button>
                <button class="export-menu-item" data-format="json">
                  JSON Data <span class="ext">.json</span>
                </button>
                <div class="export-menu-divider"></div>
                <button class="export-menu-item" data-format="glb">
                  3D Model (Binary) <span class="ext">.glb</span>
                </button>
                <button class="export-menu-item" data-format="gltf">
                  3D Model (Text) <span class="ext">.gltf</span>
                </button>
              </div>
            </div>
            <span id="editor-status" class="editor-status">Ready</span>
          </div>
        </div>
        <div id="editor-container"></div>
      </div>
      
      <!-- Resizer -->
      <div class="resizer" id="resizer"></div>
      
      <!-- 3D Viewer Panel -->
      <div class="viewer-panel">
        <div class="error-banner" id="error-banner"></div>
        <div class="error-overlay" id="error-overlay"></div>
        <div id="app"></div>
        
        <div class="info-panel">
          <h3>Selection</h3>
          <p><span class="key">Click</span> Select</p>
          <p><span class="key">Shift+Click</span> Add to selection</p>
          <p><span class="key">Drag</span> Marquee select</p>
          <p><span class="key">Ctrl/⌘+A</span> Select all</p>
          <p><span class="key">Esc</span> Deselect</p>
          
          <h3>Camera</h3>
          <p><span class="key">Alt+Drag</span> Orbit</p>
          <p><span class="key">Right-drag</span> Pan</p>
          <p><span class="key">Scroll</span> Zoom</p>
          
          <div class="mode-toggle">
            <label>
              <input type="checkbox" id="containment-mode">
              Containment mode
            </label>
            <div class="mode-indicator" id="mode-indicator">
              Intersection
            </div>
          </div>
        </div>
        
        <div id="selection-info" class="selection-info">
          <div class="details">No selection</div>
        </div>
        
        <!-- Properties Panel (shown when single element selected) -->
        <div id="properties-panel" class="properties-panel"></div>
      </div>
    </div>
    
    <!-- Delete Confirm Dialog -->
    <div class="dialog-overlay" id="delete-confirm-dialog">
      <div class="confirm-dialog">
        <div class="confirm-dialog-title">Delete <span id="delete-entity-name"></span>?</div>
        <div class="confirm-dialog-message" id="delete-message"></div>
        <div class="confirm-dialog-warning" id="delete-warning" style="display: none;">
          <div class="confirm-dialog-warning-title">⚠️ This will also delete:</div>
          <ul class="confirm-dialog-warning-list" id="delete-cascade-list"></ul>
        </div>
        <div class="dialog-buttons">
          <button class="dialog-btn cancel" id="delete-cancel">Cancel</button>
          <button class="dialog-btn primary" id="delete-confirm" style="background: #5a2d2d; border-color: #8a4a4a; color: #f88;">Delete</button>
        </div>
      </div>
    </div>
    
    <!-- Add Room Dialog -->
    <div class="dialog-overlay" id="add-room-dialog">
      <div class="dialog">
        <div class="dialog-title">Add New Room</div>
        <div class="dialog-field">
          <label for="room-name">Room Name</label>
          <input type="text" id="room-name" placeholder="e.g., Bedroom, Office" autocomplete="off">
        </div>
        <div class="dialog-row">
          <div class="dialog-field">
            <label for="room-x">X Position</label>
            <input type="number" id="room-x" value="0" step="0.5">
          </div>
          <div class="dialog-field">
            <label for="room-y">Y Position</label>
            <input type="number" id="room-y" value="0" step="0.5">
          </div>
        </div>
        <div class="dialog-row">
          <div class="dialog-field">
            <label for="room-width">Width</label>
            <input type="number" id="room-width" value="4" step="0.5" min="0.5">
          </div>
          <div class="dialog-field">
            <label for="room-height">Height</label>
            <input type="number" id="room-height" value="4" step="0.5" min="0.5">
          </div>
        </div>
        <div class="dialog-error" id="add-room-error"></div>
        <div class="dialog-buttons">
          <button class="dialog-btn cancel" id="add-room-cancel">Cancel</button>
          <button class="dialog-btn primary" id="add-room-confirm">Add Room</button>
        </div>
      </div>
    </div>
    
    <script type="module">
      import { InteractiveEditor } from './src/interactive-editor.ts';
      import { createDslEditor } from './src/dsl-editor.ts';
      import { EditorViewerSync } from './src/editor-viewer-sync.ts';
      import { PropertiesPanel } from './src/properties-panel.ts';
      import { dslPropertyEditor, dslGenerator } from './src/dsl-generator.ts';
      import { EmptyFileSystem } from 'langium';
      import { createFloorplansServices, convertFloorplanToJson } from 'floorplans-language';
      
      // Sample DSL content
      const sampleDsl = `floorplan
  config {
    default_height: 2.8,
    wall_thickness: 0.15,
    floor_thickness: 0.1
  }
  
  floor GroundFloor {
    room LivingRoom at (0, 0) size (8 x 6) walls [top: solid, right: solid, bottom: solid, left: solid]
    room Kitchen at (8.5, 0) size (5 x 6) walls [top: solid, right: solid, bottom: solid, left: open]
    room DiningRoom at (14, 0) size (5 x 6) walls [top: solid, right: solid, bottom: solid, left: solid]
    room Bedroom at (0, 7) size (6 x 5) walls [top: solid, right: solid, bottom: solid, left: solid]
    room Bathroom at (6.5, 7) size (4 x 5) walls [top: solid, right: solid, bottom: solid, left: solid]
    room Office at (11, 7) size (5 x 5) walls [top: solid, right: solid, bottom: solid, left: solid]
  }
  
  connect LivingRoom.right to Kitchen.left door at 50%
  connect Kitchen.right to DiningRoom.left door at 50%
`;
      
      // Initialize Langium services
      const services = createFloorplansServices(EmptyFileSystem);
      const parser = services.Floorplans.parser.LangiumParser;
      
      // State
      let currentJsonData = null;
      let editorSync = null;
      let parseDebounceTimeout = null;
      
      // Create DSL editor
      const dslEditor = createDslEditor({
        containerId: 'editor-container',
        initialContent: sampleDsl,
        theme: 'vs-dark',
        fontSize: 13,
        onChange: (content) => {
          // Debounce parsing
          if (parseDebounceTimeout) {
            clearTimeout(parseDebounceTimeout);
          }
          parseDebounceTimeout = setTimeout(() => {
            parseAndUpdate(content);
          }, 300);
        },
      });
      
      // Create 3D editor (initially with sample data)
      const editor3d = new InteractiveEditor({
        containerId: 'app',
        enableSelection: true,
      });
      
      // UI elements
      const editorStatus = document.getElementById('editor-status');
      const errorBanner = document.getElementById('error-banner');
      const errorOverlay = document.getElementById('error-overlay');
      const selectionInfo = document.getElementById('selection-info');
      const containmentCheckbox = document.getElementById('containment-mode');
      const modeIndicator = document.getElementById('mode-indicator');
      
      /**
       * Parse DSL and update 3D view
       */
      async function parseAndUpdate(content) {
        try {
          // Parse the DSL
          const parseResult = parser.parse(content);
          
          if (parseResult.lexerErrors.length > 0 || parseResult.parserErrors.length > 0) {
            const errors = [
              ...parseResult.lexerErrors.map(e => ({
                line: e.line ?? 1,
                column: e.column ?? 1,
                message: e.message,
              })),
              ...parseResult.parserErrors.map(e => ({
                line: e.token?.startLine ?? 1,
                column: e.token?.startColumn ?? 1,
                message: e.message,
              })),
            ];
            
            showError(errors[0].message);
            dslEditor.setErrorMarkers(errors);
            editorStatus.textContent = `${errors.length} error(s)`;
            editorStatus.className = 'editor-status error';
            // Set error state (3D view keeps last valid geometry)
            editor3d.setErrorState(true);
            return;
          }
          
          // Convert to JSON
          const conversionResult = convertFloorplanToJson(parseResult.value);
          
          if (conversionResult.errors.length > 0) {
            showError(conversionResult.errors[0].message);
            editorStatus.textContent = 'Conversion error';
            editorStatus.className = 'editor-status error';
            // Set error state (3D view keeps last valid geometry)
            editor3d.setErrorState(true);
            return;
          }
          
          // Success - update 3D view
          currentJsonData = conversionResult.data;
          editor3d.loadFloorplan(currentJsonData);
          
          // Update entity locations for sync
          if (editorSync) {
            const entityLocations = extractEntityLocations(currentJsonData);
            editorSync.updateEntityLocations(entityLocations);
          }
          
          // Clear errors (loadFloorplan already clears error state)
          hideError();
          dslEditor.clearErrorMarkers();
          editorStatus.textContent = 'Ready';
          editorStatus.className = 'editor-status success';
          
        } catch (err) {
          showError(err.message);
          editorStatus.textContent = 'Parse error';
          editorStatus.className = 'editor-status error';
          // Set error state (3D view keeps last valid geometry)
          editor3d.setErrorState(true);
        }
      }
      
      /**
       * Extract entity locations from JSON for editor sync
       */
      function extractEntityLocations(jsonData) {
        const locations = [];
        
        for (const floor of jsonData.floors) {
          for (const room of floor.rooms) {
            if (room._sourceRange) {
              locations.push({
                entityType: 'room',
                entityId: room.name,
                floorId: floor.id,
                sourceRange: room._sourceRange,
              });
            }
            
            // Extract wall locations for wall direction → 3D highlight sync
            for (const wall of room.walls || []) {
              if (wall._sourceRange) {
                locations.push({
                  entityType: 'wall',
                  entityId: `${room.name}_${wall.direction}`,
                  floorId: floor.id,
                  sourceRange: wall._sourceRange,
                });
              }
            }
          }
        }
        
        for (const conn of jsonData.connections) {
          if (conn._sourceRange) {
            locations.push({
              entityType: 'connection',
              entityId: `${conn.fromRoom}-${conn.toRoom}`,
              floorId: jsonData.floors[0]?.id ?? 'default',
              sourceRange: conn._sourceRange,
            });
          }
        }
        
        return locations;
      }
      
      /**
       * Show error in banner and dim 3D scene
       */
      function showError(message) {
        errorBanner.textContent = message;
        errorBanner.classList.add('visible');
        errorOverlay.classList.add('visible');
      }
      
      /**
       * Hide error banner and clear 3D scene dimming
       */
      function hideError() {
        errorBanner.classList.remove('visible');
        errorOverlay.classList.remove('visible');
      }
      
      /**
       * Update selection info display
       */
      function updateSelectionInfo(selection) {
        const count = selection.size;
        
        if (count === 0) {
          selectionInfo.innerHTML = '<div class="details">No selection</div>';
          selectionInfo.classList.remove('has-selection');
        } else {
          const types = new Map();
          for (const obj of selection) {
            types.set(obj.entityType, (types.get(obj.entityType) || 0) + 1);
          }
          
          const summary = Array.from(types.entries())
            .map(([type, cnt]) => `${cnt} ${type}${cnt > 1 ? 's' : ''}`)
            .join(', ');
          
          let names = '';
          if (count <= 3) {
            names = Array.from(selection).map(s => s.entityId).join(', ');
          }
          
          selectionInfo.innerHTML = `
            <div class="count">${count}</div>
            <div class="details">${summary}</div>
            ${names ? `<div class="details" style="margin-top: 4px; color: #00ff00;">${names}</div>` : ''}
          `;
          selectionInfo.classList.add('has-selection');
        }
      }
      
      // Setup selection manager listeners
      if (editor3d.selectionManager) {
        editor3d.selectionManager.onSelectionChange((event) => {
          updateSelectionInfo(event.selection);
          updatePropertiesPanel(event.selection);
        });
        
        // Setup bidirectional sync
        editorSync = new EditorViewerSync(
          dslEditor.editor,
          editor3d.selectionManager,
          { debug: false }
        );
        
        // Handle editor cursor → 3D selection (supports multi-cursor)
        editorSync.onEditorSelect((entityKey, isAdditive) => {
          // Parse the key: floorId:entityType:entityId
          const parts = entityKey.split(':');
          if (parts.length !== 3) return;
          
          const [floorId, entityType, entityId] = parts;
          
          // Find the entity in the registry and select it
          const registry = editor3d.meshRegistry;
          const entities = registry.getAllEntities();
          
          for (const entity of entities) {
            if (entity.floorId === floorId && 
                entity.entityType === entityType && 
                entity.entityId === entityId) {
              // Use isAdditive for multi-cursor support
              editor3d.selectionManager.select(entity, isAdditive);
              break;
            }
          }
        });
        
        // Handle editor text highlight → 3D preview highlight
        editorSync.onEditorHighlight((entityKeys) => {
          // Clear existing highlights first
          editor3d.selectionManager.clearHighlight();
          
          const registry = editor3d.meshRegistry;
          const entities = registry.getAllEntities();
          
          for (const entityKey of entityKeys) {
            const parts = entityKey.split(':');
            if (parts.length !== 3) continue;
            
            const [floorId, entityType, entityId] = parts;
            
            for (const entity of entities) {
              if (entity.floorId === floorId && 
                  entity.entityType === entityType && 
                  entity.entityId === entityId) {
                // Highlight (preview) without selecting
                editor3d.selectionManager.highlight(entity);
                break;
              }
            }
          }
        });
        
        // Handle clear highlight when text selection is cleared
        editorSync.onEditorHighlightClear(() => {
          editor3d.selectionManager.clearHighlight();
        });
      }
      
      // Properties Panel
      const propertiesPanel = new PropertiesPanel({
        container: 'properties-panel',
        onPropertyChange: (event) => {
          console.log('Property changed:', event);
          
          // Generate Monaco edit operation
          const sourceText = dslEditor.getValue();
          
          if (!event.sourceRange) {
            console.warn('Cannot edit: no source range available');
            return;
          }
          
          let editOp = null;
          
          if (event.entityType === 'room') {
            editOp = dslPropertyEditor.generateRoomPropertyEdit(
              sourceText,
              event.sourceRange,
              event.property,
              event.newValue
            );
          } else if (event.entityType === 'connection') {
            editOp = dslPropertyEditor.generateConnectionPropertyEdit(
              sourceText,
              event.sourceRange,
              event.property,
              event.newValue
            );
          }
          
          if (editOp) {
            // Apply the edit using Monaco's executeEdits
            const monacoEditor = dslEditor.editor;
            const model = monacoEditor.getModel();
            
            if (model) {
              // Use pushEditOperations to support undo
              model.pushEditOperations(
                [], // No selections to preserve
                [{
                  range: {
                    startLineNumber: editOp.range.startLineNumber,
                    startColumn: editOp.range.startColumn,
                    endLineNumber: editOp.range.endLineNumber,
                    endColumn: editOp.range.endColumn,
                  },
                  text: editOp.text,
                }],
                () => null // Don't change cursor position
              );
              
              console.log(`Applied edit: ${event.property} = ${event.newValue}`);
            }
          } else {
            console.warn(`Could not generate edit for ${event.entityType}.${event.property}`);
          }
        },
        onDelete: (event) => {
          console.log('Delete requested:', event);
          showDeleteConfirmation(event);
        },
      });
      
      // Show/hide properties panel based on selection
      function updatePropertiesPanel(selection) {
        if (selection.size === 1) {
          // Single selection - show properties panel
          const entity = Array.from(selection)[0];
          
          // Get entity data from JSON
          let entityData = {};
          if (currentJsonData) {
            if (entity.entityType === 'room') {
              for (const floor of currentJsonData.floors) {
                const room = floor.rooms.find(r => r.name === entity.entityId);
                if (room) {
                  entityData = {
                    name: room.name,
                    x: room.x,
                    y: room.z, // Note: z is the Y in 2D
                    width: room.width,
                    height: room.height,
                    roomHeight: room.roomHeight,
                    style: room.style,
                  };
                  break;
                }
              }
            } else if (entity.entityType === 'wall') {
              // Parse wall entity ID (e.g., "Kitchen_top")
              const match = entity.entityId.match(/^(.+)_(top|bottom|left|right)$/);
              if (match) {
                entityData = {
                  room: match[1],
                  direction: match[2],
                  type: 'solid', // Would need to look up actual type
                };
              }
            } else if (entity.entityType === 'connection') {
              // Parse connection entity ID (e.g., "LivingRoom-Kitchen")
              const parts = entity.entityId.split('-');
              if (parts.length >= 2) {
                const conn = currentJsonData.connections?.find(
                  c => c.fromRoom === parts[0] && c.toRoom === parts.slice(1).join('-')
                );
                entityData = {
                  fromRoom: parts[0],
                  toRoom: parts.slice(1).join('-'),
                  type: conn?.doorType ?? 'door',
                  position: conn?.position ?? 50,
                };
              }
            }
          }
          
          propertiesPanel.show(entity, entityData);
        } else {
          // Multiple or no selection - hide properties panel
          propertiesPanel.hide();
        }
      }
      
      // Mode toggle
      containmentCheckbox.addEventListener('change', (e) => {
        const mode = e.target.checked ? 'containment' : 'intersection';
        editor3d.setMarqueeMode(mode);
        modeIndicator.textContent = mode === 'containment' ? 'Containment' : 'Intersection';
        modeIndicator.style.color = mode === 'containment' ? '#ff9500' : '#4a9eff';
      });
      
      // Initialize mode from saved preference
      try {
        const savedMode = localStorage.getItem('floorplan-marquee-mode');
        if (savedMode === 'containment') {
          containmentCheckbox.checked = true;
          editor3d.setMarqueeMode('containment');
          modeIndicator.textContent = 'Containment';
          modeIndicator.style.color = '#ff9500';
        }
      } catch (e) {}
      
      // Resizer functionality
      const resizer = document.getElementById('resizer');
      const editorPanel = document.querySelector('.editor-panel');
      let isResizing = false;
      
      resizer.addEventListener('mousedown', (e) => {
        isResizing = true;
        document.body.style.cursor = 'col-resize';
        e.preventDefault();
      });
      
      document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;
        const newWidth = e.clientX;
        if (newWidth >= 200 && newWidth <= 800) {
          editorPanel.style.width = `${newWidth}px`;
        }
      });
      
      document.addEventListener('mouseup', () => {
        isResizing = false;
        document.body.style.cursor = '';
      });
      
      // Initial parse
      parseAndUpdate(sampleDsl);
      
      // Export functionality
      const exportBtn = document.getElementById('export-btn');
      const exportMenu = document.getElementById('export-menu');
      
      // Track filename for exports
      let currentFilename = 'floorplan';
      
      // Toggle export menu
      exportBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        exportMenu.classList.toggle('visible');
      });
      
      // Close menu when clicking outside
      document.addEventListener('click', () => {
        exportMenu.classList.remove('visible');
      });
      
      // Handle export menu items
      exportMenu.addEventListener('click', async (e) => {
        const item = e.target.closest('.export-menu-item');
        if (!item) return;
        
        const format = item.dataset.format;
        exportMenu.classList.remove('visible');
        
        try {
          switch (format) {
            case 'dsl':
              exportDsl();
              break;
            case 'json':
              exportJson();
              break;
            case 'glb':
              await exportGlb();
              break;
            case 'gltf':
              await exportGltf();
              break;
          }
        } catch (err) {
          console.error(`Export failed:`, err);
          alert(`Export failed: ${err.message}`);
        }
      });
      
      /**
       * Export DSL file
       */
      function exportDsl() {
        const content = dslEditor.getValue();
        downloadFile(`${currentFilename}.floorplan`, content, 'text/plain');
      }
      
      /**
       * Export JSON data
       */
      function exportJson() {
        if (!currentJsonData) {
          alert('No valid floorplan data to export. Fix parse errors first.');
          return;
        }
        
        // Create clean JSON without internal source ranges
        const cleanData = JSON.parse(JSON.stringify(currentJsonData));
        removeSourceRanges(cleanData);
        
        const content = JSON.stringify(cleanData, null, 2);
        downloadFile(`${currentFilename}.json`, content, 'application/json');
      }
      
      /**
       * Remove _sourceRange properties from object tree
       */
      function removeSourceRanges(obj) {
        if (Array.isArray(obj)) {
          obj.forEach(removeSourceRanges);
        } else if (obj && typeof obj === 'object') {
          delete obj._sourceRange;
          Object.values(obj).forEach(removeSourceRanges);
        }
      }
      
      /**
       * Export GLB (binary GLTF)
       */
      async function exportGlb() {
        const { GLTFExporter } = await import('three/examples/jsm/exporters/GLTFExporter.js');
        const exporter = new GLTFExporter();
        
        const scene = editor3d.scene;
        if (!scene) {
          alert('No 3D scene to export');
          return;
        }
        
        exporter.parse(
          scene,
          (result) => {
            // result is ArrayBuffer for binary
            const blob = new Blob([result], { type: 'application/octet-stream' });
            downloadBlob(`${currentFilename}.glb`, blob);
          },
          (error) => {
            console.error('GLB export error:', error);
            throw error;
          },
          { binary: true }
        );
      }
      
      /**
       * Export GLTF (text format)
       */
      async function exportGltf() {
        const { GLTFExporter } = await import('three/examples/jsm/exporters/GLTFExporter.js');
        const exporter = new GLTFExporter();
        
        const scene = editor3d.scene;
        if (!scene) {
          alert('No 3D scene to export');
          return;
        }
        
        exporter.parse(
          scene,
          (result) => {
            // result is JSON object for non-binary
            const content = JSON.stringify(result, null, 2);
            downloadFile(`${currentFilename}.gltf`, content, 'model/gltf+json');
          },
          (error) => {
            console.error('GLTF export error:', error);
            throw error;
          },
          { binary: false }
        );
      }
      
      /**
       * Download text content as file
       */
      function downloadFile(filename, content, mimeType) {
        const blob = new Blob([content], { type: mimeType });
        downloadBlob(filename, blob);
      }
      
      /**
       * Download blob as file
       */
      function downloadBlob(filename, blob) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      
      // Add Room functionality
      const addRoomBtn = document.getElementById('add-room-btn');
      const addRoomDialog = document.getElementById('add-room-dialog');
      const addRoomCancel = document.getElementById('add-room-cancel');
      const addRoomConfirm = document.getElementById('add-room-confirm');
      const addRoomError = document.getElementById('add-room-error');
      const roomNameInput = document.getElementById('room-name');
      const roomXInput = document.getElementById('room-x');
      const roomYInput = document.getElementById('room-y');
      const roomWidthInput = document.getElementById('room-width');
      const roomHeightInput = document.getElementById('room-height');
      
      // Open dialog
      addRoomBtn.addEventListener('click', () => {
        // Reset form
        roomNameInput.value = '';
        roomXInput.value = '0';
        roomYInput.value = '0';
        roomWidthInput.value = '4';
        roomHeightInput.value = '4';
        addRoomError.classList.remove('visible');
        addRoomError.textContent = '';
        
        addRoomDialog.classList.add('visible');
        roomNameInput.focus();
      });
      
      // Close dialog
      addRoomCancel.addEventListener('click', () => {
        addRoomDialog.classList.remove('visible');
      });
      
      // Close on overlay click
      addRoomDialog.addEventListener('click', (e) => {
        if (e.target === addRoomDialog) {
          addRoomDialog.classList.remove('visible');
        }
      });
      
      // Close on Escape
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && addRoomDialog.classList.contains('visible')) {
          addRoomDialog.classList.remove('visible');
        }
      });
      
      // Confirm add room
      addRoomConfirm.addEventListener('click', () => {
        addRoom();
      });
      
      // Enter key in form
      roomNameInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') addRoom();
      });
      
      /**
       * Add a new room to the floorplan
       */
      function addRoom() {
        // Validate
        const name = roomNameInput.value.trim();
        if (!name) {
          showAddRoomError('Room name is required');
          roomNameInput.focus();
          return;
        }
        
        // Check for valid identifier (no spaces, start with letter)
        if (!/^[A-Za-z][A-Za-z0-9_]*$/.test(name)) {
          showAddRoomError('Room name must start with a letter and contain only letters, numbers, and underscores');
          roomNameInput.focus();
          return;
        }
        
        // Check for duplicate names
        if (currentJsonData) {
          const existingNames = new Set();
          for (const floor of currentJsonData.floors) {
            for (const room of floor.rooms) {
              existingNames.add(room.name);
            }
          }
          if (existingNames.has(name)) {
            showAddRoomError(`Room '${name}' already exists`);
            roomNameInput.focus();
            return;
          }
        }
        
        const x = parseFloat(roomXInput.value) || 0;
        const y = parseFloat(roomYInput.value) || 0;
        const width = parseFloat(roomWidthInput.value) || 4;
        const height = parseFloat(roomHeightInput.value) || 4;
        
        if (width < 0.5 || height < 0.5) {
          showAddRoomError('Width and height must be at least 0.5');
          return;
        }
        
        // Generate DSL
        const roomDsl = dslGenerator.generateRoom({
          name,
          x,
          y,
          width,
          height,
        });
        
        // Find insertion point (after last room in first floor)
        const insertPoint = findRoomInsertionPoint();
        if (!insertPoint) {
          showAddRoomError('Could not find floor block to add room');
          return;
        }
        
        // Insert the room DSL
        const model = dslEditor.editor.getModel();
        if (model) {
          model.pushEditOperations(
            [],
            [{
              range: {
                startLineNumber: insertPoint.line,
                startColumn: insertPoint.column,
                endLineNumber: insertPoint.line,
                endColumn: insertPoint.column,
              },
              text: '\n' + roomDsl,
            }],
            () => null
          );
        }
        
        // Close dialog
        addRoomDialog.classList.remove('visible');
      }
      
      /**
       * Find the line/column to insert a new room (after last room in first floor)
       */
      function findRoomInsertionPoint() {
        const content = dslEditor.getValue();
        const lines = content.split('\n');
        
        // Find the last room definition in the first floor
        let lastRoomLine = -1;
        let floorStarted = false;
        let floorIndent = 0;
        
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          
          // Check for floor block start
          if (/^\s*floor\s+\S+/.test(line)) {
            floorStarted = true;
            floorIndent = line.match(/^(\s*)/)[1].length;
          }
          
          // Check for room definition
          if (floorStarted && /^\s*room\s+\S+/.test(line)) {
            lastRoomLine = i;
          }
          
          // Check for floor block end (closing brace at same indent)
          if (floorStarted && line.trim() === '}') {
            const braceIndent = line.match(/^(\s*)/)[1].length;
            if (braceIndent === floorIndent) {
              break; // End of first floor
            }
          }
        }
        
        if (lastRoomLine === -1) {
          // No rooms found, try to find after floor { line
          for (let i = 0; i < lines.length; i++) {
            if (/^\s*floor\s+\S+.*\{/.test(lines[i])) {
              return { line: i + 2, column: 1 }; // Line after floor {
            }
          }
          return null;
        }
        
        // Insert after the last room line
        return { line: lastRoomLine + 2, column: 1 }; // +2 because Monaco is 1-indexed and we want line after
      }
      
      /**
       * Show error in add room dialog
       */
      function showAddRoomError(message) {
        addRoomError.textContent = message;
        addRoomError.classList.add('visible');
      }
      
      // Delete functionality
      const deleteConfirmDialog = document.getElementById('delete-confirm-dialog');
      const deleteEntityName = document.getElementById('delete-entity-name');
      const deleteMessage = document.getElementById('delete-message');
      const deleteWarning = document.getElementById('delete-warning');
      const deleteCascadeList = document.getElementById('delete-cascade-list');
      const deleteCancel = document.getElementById('delete-cancel');
      const deleteConfirmBtn = document.getElementById('delete-confirm');
      
      let pendingDeleteEvent = null;
      let pendingCascadeConnections = [];
      
      /**
       * Show delete confirmation dialog
       */
      function showDeleteConfirmation(event) {
        pendingDeleteEvent = event;
        pendingCascadeConnections = [];
        
        // Set entity name
        deleteEntityName.textContent = `${event.entityType}: ${event.entityId}`;
        
        // Set message based on entity type
        if (event.entityType === 'room') {
          deleteMessage.textContent = `Are you sure you want to delete the room "${event.entityId}"?`;
          
          // Check for connections that reference this room
          if (currentJsonData && currentJsonData.connections) {
            const affectedConnections = currentJsonData.connections.filter(
              conn => conn.fromRoom === event.entityId || conn.toRoom === event.entityId
            );
            
            if (affectedConnections.length > 0) {
              pendingCascadeConnections = affectedConnections;
              deleteCascadeList.innerHTML = affectedConnections.map(
                conn => `<li>${conn.fromRoom} → ${conn.toRoom} (${conn.doorType})</li>`
              ).join('');
              deleteWarning.style.display = 'block';
            } else {
              deleteWarning.style.display = 'none';
            }
          } else {
            deleteWarning.style.display = 'none';
          }
        } else if (event.entityType === 'connection') {
          deleteMessage.textContent = `Are you sure you want to delete this connection?`;
          deleteWarning.style.display = 'none';
        } else {
          deleteMessage.textContent = `Are you sure you want to delete "${event.entityId}"?`;
          deleteWarning.style.display = 'none';
        }
        
        deleteConfirmDialog.classList.add('visible');
      }
      
      // Close delete dialog
      deleteCancel.addEventListener('click', () => {
        deleteConfirmDialog.classList.remove('visible');
        pendingDeleteEvent = null;
        pendingCascadeConnections = [];
      });
      
      // Close on overlay click
      deleteConfirmDialog.addEventListener('click', (e) => {
        if (e.target === deleteConfirmDialog) {
          deleteConfirmDialog.classList.remove('visible');
          pendingDeleteEvent = null;
          pendingCascadeConnections = [];
        }
      });
      
      // Confirm delete
      deleteConfirmBtn.addEventListener('click', () => {
        if (pendingDeleteEvent) {
          executeDelete(pendingDeleteEvent, pendingCascadeConnections);
        }
        deleteConfirmDialog.classList.remove('visible');
        pendingDeleteEvent = null;
        pendingCascadeConnections = [];
      });
      
      /**
       * Execute delete operation
       */
      function executeDelete(event, cascadeConnections) {
        const model = dslEditor.editor.getModel();
        if (!model) return;
        
        // Collect all ranges to delete (entity + cascade connections)
        const rangesToDelete = [];
        
        // Add main entity range
        if (event.sourceRange) {
          rangesToDelete.push({
            range: event.sourceRange,
            description: `${event.entityType}: ${event.entityId}`,
          });
        }
        
        // Add cascade connection ranges
        for (const conn of cascadeConnections) {
          if (conn._sourceRange) {
            rangesToDelete.push({
              range: conn._sourceRange,
              description: `connection: ${conn.fromRoom} → ${conn.toRoom}`,
            });
          }
        }
        
        if (rangesToDelete.length === 0) {
          console.warn('No source ranges available for deletion');
          return;
        }
        
        // Sort ranges by position (end to start) to delete from bottom up
        // This prevents range shifting issues
        rangesToDelete.sort((a, b) => {
          if (a.range.endLine !== b.range.endLine) {
            return b.range.endLine - a.range.endLine;
          }
          return b.range.endColumn - a.range.endColumn;
        });
        
        // Build edit operations
        const edits = rangesToDelete.map(({ range }) => ({
          range: {
            startLineNumber: range.startLine + 1,
            startColumn: range.startColumn + 1,
            endLineNumber: range.endLine + 1,
            endColumn: range.endColumn + 2, // +2 to include trailing newline
          },
          text: '',
        }));
        
        // Apply all edits
        model.pushEditOperations([], edits, () => null);
        
        // Clear selection
        if (editor3d.selectionManager) {
          editor3d.selectionManager.clearSelection();
        }
        
        // Hide properties panel
        propertiesPanel.hide();
        
        console.log(`Deleted ${rangesToDelete.length} entities`);
      }
      
      // Expose for debugging
      window.editor3d = editor3d;
      window.dslEditor = dslEditor;
      window.editorSync = editorSync;
      console.log('Interactive Editor with DSL sync initialized');
      console.log('Access: window.editor3d, window.dslEditor, window.editorSync');
    </script>
  </body>
</html>
